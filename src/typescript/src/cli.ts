
import { AptosParserRepo, getTypeTagFullname, StructTag, parseTypeTagOrThrow, u8, u64, u128, print, strToU8, u8str, DummyCache } from "@manahippo/move-to-ts";
import { AptosAccount, AptosClient, HexString, Types } from "aptos";
import { Command } from "commander";
import { getProjectRepo } from "./";
import * as fs from "fs";
import * as yaml from "yaml";
import * as Econia from './econia';

export const readConfig = (program: Command) => {
  const {config, profile} = program.opts();
  const ymlContent = fs.readFileSync(config, {encoding: "utf-8"});
  const result = yaml.parse(ymlContent);
  //console.log(result);
  if (!result.profiles) {
    throw new Error("Expect a profiles to be present in yaml config");
  }
  if (!result.profiles[profile]) {
    throw new Error(`Expect a ${profile} profile to be present in yaml config`);
  }
  const url = result.profiles[profile].rest_url;
  const privateKeyStr = result.profiles[profile].private_key;
  if (!url) {
    throw new Error(`Expect rest_url to be present in ${profile} profile`);
  }
  if (!privateKeyStr) {
    throw new Error(`Expect private_key to be present in ${profile} profile`);
  }
  const privateKey = new HexString(privateKeyStr);
  const client = new AptosClient(result.profiles[profile].rest_url);
  const account = new AptosAccount(privateKey.toUint8Array());
  console.log(`Using address ${account.address().hex()}`);
  return {client, account};
}

export async function sendPayloadTx(
  client: AptosClient,
  account: AptosAccount,
  payload: Types.TransactionPayload,
  max_gas=1000
){
  const txnRequest = await client.generateTransaction(account.address(), payload, {max_gas_amount: `${max_gas}`});
  const signedTxn = await client.signTransaction(account, txnRequest);
  const txnResult = await client.submitTransaction(signedTxn);
  await client.waitForTransaction(txnResult.hash);
  const txDetails = (await client.getTransactionByHash(txnResult.hash)) as Types.UserTransaction;
  console.log(txDetails);
}

const program = new Command();

program
  .name('move-ts-cli')
  .description('Move TS CLI generated by move-to-ts')
  .requiredOption('-c, --config <path>', 'path to your aptos config.yml (generated with "aptos init")')
  .option('-p, --profile <PROFILE>', 'aptos config profile to use', 'default')


const coins_init_coin_types = async () => {
  const {client, account} = readConfig(program);

  const payload = Econia.Coins.buildPayload_init_coin_types();
  await sendPayloadTx(client, account, payload);
}

program
  .command("coins:init-coin-types")
  .description("")

  .action(coins_init_coin_types);


const coins_mint = async (CoinType: string, amount: string) => {
  const {client, account} = readConfig(program);
  const CoinType_ = parseTypeTagOrThrow(CoinType);
  const amount_ = u64(amount);
  const payload = Econia.Coins.buildPayload_mint(amount_, [CoinType_]);
  await sendPayloadTx(client, account, payload);
}

program
  .command("coins:mint")
  .description("")
  .argument('<TYPE_CoinType>')
  .argument('<amount>')
  .action(coins_mint);


const init_init_econia = async () => {
  const {client, account} = readConfig(program);

  const payload = Econia.Init.buildPayload_init_econia();
  await sendPayloadTx(client, account, payload);
}

program
  .command("init:init-econia")
  .description("")

  .action(init_init_econia);


const market_cancel_limit_order_user = async (B: string, Q: string, E: string, host: string, side: string, order_id: string) => {
  const {client, account} = readConfig(program);
  const B_ = parseTypeTagOrThrow(B);
  const Q_ = parseTypeTagOrThrow(Q);
  const E_ = parseTypeTagOrThrow(E);
  const host_ = new HexString(host);
  const side_ = side=='true';
  const order_id_ = u128(order_id);
  const payload = Econia.Market.buildPayload_cancel_limit_order_user(host_, side_, order_id_, [B_, Q_, E_]);
  await sendPayloadTx(client, account, payload);
}

program
  .command("market:cancel-limit-order-user")
  .description("")
  .argument('<TYPE_B>')
  .argument('<TYPE_Q>')
  .argument('<TYPE_E>')
  .argument('<host>')
  .argument('<side>')
  .argument('<order_id>')
  .action(market_cancel_limit_order_user);


const market_fill_market_order_user = async (B: string, Q: string, E: string, host: string, style: string, max_base_parcels: string, max_quote_units: string) => {
  const {client, account} = readConfig(program);
  const B_ = parseTypeTagOrThrow(B);
  const Q_ = parseTypeTagOrThrow(Q);
  const E_ = parseTypeTagOrThrow(E);
  const host_ = new HexString(host);
  const style_ = style=='true';
  const max_base_parcels_ = u64(max_base_parcels);
  const max_quote_units_ = u64(max_quote_units);
  const payload = Econia.Market.buildPayload_fill_market_order_user(host_, style_, max_base_parcels_, max_quote_units_, [B_, Q_, E_]);
  await sendPayloadTx(client, account, payload);
}

program
  .command("market:fill-market-order-user")
  .description("")
  .argument('<TYPE_B>')
  .argument('<TYPE_Q>')
  .argument('<TYPE_E>')
  .argument('<host>')
  .argument('<style>')
  .argument('<max_base_parcels>')
  .argument('<max_quote_units>')
  .action(market_fill_market_order_user);


const market_place_limit_order_user = async (B: string, Q: string, E: string, host: string, side: string, base_parcels: string, price: string) => {
  const {client, account} = readConfig(program);
  const B_ = parseTypeTagOrThrow(B);
  const Q_ = parseTypeTagOrThrow(Q);
  const E_ = parseTypeTagOrThrow(E);
  const host_ = new HexString(host);
  const side_ = side=='true';
  const base_parcels_ = u64(base_parcels);
  const price_ = u64(price);
  const payload = Econia.Market.buildPayload_place_limit_order_user(host_, side_, base_parcels_, price_, [B_, Q_, E_]);
  await sendPayloadTx(client, account, payload);
}

program
  .command("market:place-limit-order-user")
  .description("")
  .argument('<TYPE_B>')
  .argument('<TYPE_Q>')
  .argument('<TYPE_E>')
  .argument('<host>')
  .argument('<side>')
  .argument('<base_parcels>')
  .argument('<price>')
  .action(market_place_limit_order_user);


const market_register_market = async (B: string, Q: string, E: string) => {
  const {client, account} = readConfig(program);
  const B_ = parseTypeTagOrThrow(B);
  const Q_ = parseTypeTagOrThrow(Q);
  const E_ = parseTypeTagOrThrow(E);
  const payload = Econia.Market.buildPayload_register_market([B_, Q_, E_]);
  await sendPayloadTx(client, account, payload);
}

program
  .command("market:register-market")
  .description("")
  .argument('<TYPE_B>')
  .argument('<TYPE_Q>')
  .argument('<TYPE_E>')
  .action(market_register_market);


const user_deposit_collateral_coinstore = async (B: string, Q: string, E: string, custodian_id: string, base: string, amount: string) => {
  const {client, account} = readConfig(program);
  const B_ = parseTypeTagOrThrow(B);
  const Q_ = parseTypeTagOrThrow(Q);
  const E_ = parseTypeTagOrThrow(E);
  const custodian_id_ = u64(custodian_id);
  const base_ = base=='true';
  const amount_ = u64(amount);
  const payload = Econia.User.buildPayload_deposit_collateral_coinstore(custodian_id_, base_, amount_, [B_, Q_, E_]);
  await sendPayloadTx(client, account, payload);
}

program
  .command("user:deposit-collateral-coinstore")
  .description("")
  .argument('<TYPE_B>')
  .argument('<TYPE_Q>')
  .argument('<TYPE_E>')
  .argument('<custodian_id>')
  .argument('<base>')
  .argument('<amount>')
  .action(user_deposit_collateral_coinstore);


const user_register_market_account = async (B: string, Q: string, E: string, custodian_id: string) => {
  const {client, account} = readConfig(program);
  const B_ = parseTypeTagOrThrow(B);
  const Q_ = parseTypeTagOrThrow(Q);
  const E_ = parseTypeTagOrThrow(E);
  const custodian_id_ = u64(custodian_id);
  const payload = Econia.User.buildPayload_register_market_account(custodian_id_, [B_, Q_, E_]);
  await sendPayloadTx(client, account, payload);
}

program
  .command("user:register-market-account")
  .description("")
  .argument('<TYPE_B>')
  .argument('<TYPE_Q>')
  .argument('<TYPE_E>')
  .argument('<custodian_id>')
  .action(user_register_market_account);


const user_withdraw_collateral_coinstore = async (B: string, Q: string, E: string, custodian_id: string, base: string, amount: string) => {
  const {client, account} = readConfig(program);
  const B_ = parseTypeTagOrThrow(B);
  const Q_ = parseTypeTagOrThrow(Q);
  const E_ = parseTypeTagOrThrow(E);
  const custodian_id_ = u64(custodian_id);
  const base_ = base=='true';
  const amount_ = u64(amount);
  const payload = Econia.User.buildPayload_withdraw_collateral_coinstore(custodian_id_, base_, amount_, [B_, Q_, E_]);
  await sendPayloadTx(client, account, payload);
}

program
  .command("user:withdraw-collateral-coinstore")
  .description("")
  .argument('<TYPE_B>')
  .argument('<TYPE_Q>')
  .argument('<TYPE_E>')
  .argument('<custodian_id>')
  .argument('<base>')
  .argument('<amount>')
  .action(user_withdraw_collateral_coinstore);



const OrderBook_book_orders_sdk = async (owner: string, B: string, Q: string, E: string) => {
  const {client} = readConfig(program);
  const repo = getProjectRepo();
  const owner_ = new HexString(owner);
  const value = await Econia.Market.OrderBook.load(repo, client, owner_, [parseTypeTagOrThrow(B), parseTypeTagOrThrow(Q), parseTypeTagOrThrow(E)])
  print(value.book_orders_sdk());
}

program
  .command("OrderBook:book-orders-sdk")
  .argument("<ADDRESS:owner>")
  .argument('<TYPE_B>')
  .argument('<TYPE_Q>')
  .argument('<TYPE_E>')
  .action(OrderBook_book_orders_sdk)


const OrderBook_book_price_levels_sdk = async (owner: string, B: string, Q: string, E: string) => {
  const {client} = readConfig(program);
  const repo = getProjectRepo();
  const owner_ = new HexString(owner);
  const value = await Econia.Market.OrderBook.load(repo, client, owner_, [parseTypeTagOrThrow(B), parseTypeTagOrThrow(Q), parseTypeTagOrThrow(E)])
  print(value.book_price_levels_sdk());
}

program
  .command("OrderBook:book-price-levels-sdk")
  .argument("<ADDRESS:owner>")
  .argument('<TYPE_B>')
  .argument('<TYPE_Q>')
  .argument('<TYPE_E>')
  .action(OrderBook_book_price_levels_sdk)


const OrderBook_get_orders_sdk = async (owner: string, B: string, Q: string, E: string, side: string) => {
  const {client} = readConfig(program);
  const repo = getProjectRepo();
  const owner_ = new HexString(owner);
  const value = await Econia.Market.OrderBook.load(repo, client, owner_, [parseTypeTagOrThrow(B), parseTypeTagOrThrow(Q), parseTypeTagOrThrow(E)])
  print(value.get_orders_sdk(side=='true'));
}

program
  .command("OrderBook:get-orders-sdk")
  .argument("<ADDRESS:owner>")
  .argument('<TYPE_B>')
  .argument('<TYPE_Q>')
  .argument('<TYPE_E>')
  .argument('<side>')
  .action(OrderBook_get_orders_sdk)


const OrderBook_simulate_swap_sdk = async (owner: string, B: string, Q: string, E: string, style: string, coins_in: string) => {
  const {client} = readConfig(program);
  const repo = getProjectRepo();
  const owner_ = new HexString(owner);
  const value = await Econia.Market.OrderBook.load(repo, client, owner_, [parseTypeTagOrThrow(B), parseTypeTagOrThrow(Q), parseTypeTagOrThrow(E)])
  print(value.simulate_swap_sdk(style=='true', u64(coins_in)));
}

program
  .command("OrderBook:simulate-swap-sdk")
  .argument("<ADDRESS:owner>")
  .argument('<TYPE_B>')
  .argument('<TYPE_Q>')
  .argument('<TYPE_E>')
  .argument('<style>')
  .argument('<coins_in>')
  .action(OrderBook_simulate_swap_sdk)


program.parse();
